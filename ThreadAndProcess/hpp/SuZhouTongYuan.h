#pragma once

//////////////////////////////////////////////////////////////////////////
// SuzhouTongyuan Soft Control
// 练习C++
//////////////////////////////////////////////////////////////////////////


#include <iostream>
#include <sstream>
#include <vector>
#include <cstring>
#include <string>

using namespace std;

/*
在C++中处理复杂的内存释放通常需要仔细考虑和规划，以避免内存泄漏和悬空指针等问题。以下是一些可能有助于解决此类问题的最佳实践：
    使用智能指针：C++11及以后版本提供了unique_ptr、shared_ptr和weak_ptr三种智能指针，它们可以管理资源的所有权，并在必要时自动释放所指向的内存块。
    使用智能指针可以显著减少因手动内存管理而引起的错误和漏洞。
    遵循“准则：谁分配谁释放”的原则：确保正确地匹配每个new或new[]操作与相应的delete或delete[]操作，以防止分配和释放不一致而导致的内存泄漏。
    在资源分配期间记录状态：如果使用malloc或realloc等C库函数分配内存，则必须使用相应的释放函数（如free）对其进行释放。另外，可以将资源分配封装到对象中，
    并使用RAII (Resource Acquisition Is Initialization)技术来自动管理该对象的生命周期。
    适当设置成员变量初始化和析构函数： 如果您创建了一个包含大量成员变量的类，请务必在构造函数中安排每个变量的初始化，并在析构函数中明确地清理所涉及的任何资源（如指针、文件等）。
    进行内存泄漏检查：如果您怀疑自己创建了内存泄漏，则可以使用各种工具来检测和诊断内存泄漏问题。例如，可以使用Valgrind、Visual Studio的内置内存检测器等工具来检测和诊断内存管理错误。
 */



class Shape
{
public:
    Shape(const char* id, const char* name);    

    virtual ~Shape()
    {
        //delete shapeName;
        delete[] shapeName;  //释放动态分配的数组内存
    }

    /*
    const char * getName()
    {
        return shapeName;
    }*/

    const char* getName() const // 修正getName()方法的返回类型，为了避免通过getName()方法修改shapeName变量
    {
        return shapeName;
    }

private:
    char* shapeName;
};



//////////////////////////////////////////////////////////////////////////
// Main 此处为测试代码，可以按需修改以测试前面编写的函数
//////////////////////////////////////////////////////////////////////////


class SuZhouTongYuan 
{
public:
    SuZhouTongYuan();
    ~SuZhouTongYuan()
    {

    }
    void Do();
    //////////////////////////////////////////////////////////////////////////
    // (1) 改错题
    // 无符号规则的考察
    //////////////////////////////////////////////////////////////////////////
    void TestVectorTraversor();
    //////////////////////////////////////////////////////////////////////////
    // (2) 改错题
    //////////////////////////////////////////////////////////////////////////
    void Get100Memory(char*& p);
    void TestGetMemory();
    //////////////////////////////////////////////////////////////////////////
    // (3) 改错题
    //////////////////////////////////////////////////////////////////////////
    void TestTheShapeClass();


    //////////////////////////////////////////////////////////////////////////
    // (4) 算法实现题A
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // (5) 算法实现题B
    //////////////////////////////////////////////////////////////////////////

    /*
    题：ArrayTest
        术语：数组是有序的元素序列，组成数组的各个元素称为数组分量。
              用于区分数组的各个元素的数字编号称为下标。

        功能：根据输入的数组维度，打印出该数组的所有数组分量，数组下标是从0开始。

        注意：数组维度不是固定的，可以是一维数组、二维数组、三维数组、...、N维数组。

        例如：一维数组:
        input = {3}
        output = {
            A[0], A[1], A[2]
        }

        例如，二维数组：
        input = {2,3}
        output = {
            A[0][0], A[0][1], A[0][2],
            A[1][0], A[1][1], A[1][2]
        }

        例如，三维数组：
        input = {3,2,3}
        output = {
            A[0][0][0], A[0][0][1], A[0][0][2],
            A[0][1][0], A[0][1][1], A[0][1][2],
            A[1][0][0], A[1][0][1], A[1][0][2],
            A[1][1][0], A[1][1][1], A[1][1][2],
            A[2][0][0], A[2][0][1], A[2][0][2],
            A[2][1][0], A[2][1][1], A[2][1][2]
        }

        例如，N维数组：
        ...
    */
    void CreateInputDataB(vector<int>& input);
    void printArray(const string& array_name, const vector<int>& input, vector<int>& indexes, int currDim);
    void PrintArray(const std::string& array_name, const vector<int>& input);
    void TestArrayAlgorithm();

};

